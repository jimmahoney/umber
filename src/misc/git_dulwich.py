# --------------------------------
# my older implementation ... which I gave up on.
# It was slow - sometimes painfully slow - awkward to manage,
# and at times difficult to install the dependencies
#
#from dulwich import porcelain
#from dulwich.repo import Repo
#from dulwich.object_store import tree_lookup_path
#
# def parse_porcelain_log(logstring):
#     """ parse the string (stream) generated by from porcelain.log(file)
#         into a modification history of the file
#         and return a list of tuples [(githash, date, author)] """
#     #
#     # The logstring input is e.g.
#     #
#     #   u'--------------------------------------------------\n
#     #   commit: d2ecde1b475eafa1293f4827de656d40ee13aaac\n
#     #   Author: Jim Mahoney <jim@mahoney.cc>\n
#     #   Date:   Tue Jul 10 2018 18:01:33 +0000\n\n
#     #   porcelain commit file3\n\n
#     #   --------------------------------------------------\n
#     #   commit: a4995962bac1bded32e8a75d989378766b0f1bfd\n
#     #   Author: Jim Mahoney <jim@mahoney.cc>\n
#     #   Date:   Tue Jul 10 2018 13:58:14 -0400\n\n
#     #   file 3 initial\n\n
#     #   --------------------------------------------------\n
#     #   commit: 3b9826ccaffe0f833ca65864c28118efd6bf65fb\n
#     #   Author: Jim Mahoney <jim@mahoney.cc>\n
#     #   Date:   Mon Jul 09 2018 23:05:29 +0000\n
#     #   --message=user:tedteacher\n\n\n'
#     #
#     # The data timezone is slightly different for git vs dulwich commits.
#     # Umber commits store the web user as --message=user: , and that is the
#     # the only user that this will pay attention to; else author is left blank.
#     #
#     # The dash string between entries is 50 characters long.
#     # '--------------------------------------------------')
#     #           1         2         3         4         5
#     #  12345678901234567890123456789012345678901234567890
#     #
#     result = []
#     for revstring in logstring.split('-'*50):
#         lines = revstring.split('\n')
#         #print_debug("lines : {}".format(lines))
#         (githash, date, author) = ('', '', '')
#         for line in lines:
#             #print_debug("line = '{}'".format(line))
#             if line:
#                 if line[:7] == 'commit:':
#                     githash = line[7:].strip()
#                 if line[:5] == 'Date:':
#                     date = Time(line[5:].strip()).daydatetimesec()
#                 if line[:15] == '--message=user:':
#                     author = line[15:].strip()
#         if githash:
#             result.append((githash, date, author))
#         #print_debug('parce_porcelain_log: {}'.format(result))
#     return result
#
# def dulwich_get_file_revision(repo, commit, path):
#     """ Return a previous version of a file """
#     # adapted from http://www.aaronheld.com/post/using-python-dulwich-to-load-any-version-of-a-file-from-a-local-git-repo
#     #  repo : absolute path to git repository e.g. '/Users/mahoney/Desktop/testrepo'
#     #  commit : sha1 hash of a commit e.g. 'd2ecde1b475eafa1293f4827de656d40ee13aaac'
#     #  path : relative path of file beneath repo e.g. 'folder/file1.txt'
#     r = Repo(repo)             # r is hash_table : sha keys => objects (commit,tree,blob,tag)
#     tree = r[commit].tree      # same as r.get_object(commit)
#     (mode, file_sha) = tree_lookup_path(r.get_object, tree, path)
#     return r[file_sha].data

# class Git:
#     """ a wrapper around www.dulwich.io - python git interface """
    
#     def __init__(self):
#         pass

#     def add_and_commit_all(self):
#         """ add and commit all changed files as user admin """
#         # Used after creating a new course.
#         # See https://www.dulwich.io/apidocs/dulwich.porcelain.html#add
#         try:
#             # This apparently has unicode path conversion issues
#             # on the production server.
#             porcelain.add(os_git, paths=None)
#             porcelain.commit(os_git, '--message=user:admin')
#         except:
#             # Instead just run umber_cleanup (which also commits changed files)
#             # in a fork.
#             # OOPS - this doesn't work either.
#             pid = os.spawnlp(os.P_NOWAIT, umber_cleanup, 'umber_cleanup', '')
 #   
#     def add_and_commit(self, page, abspath=None):
#         """ commit abspath or this page or this folder to git repo """
#         # path vs relative seems strangely picky - this one wants abspath.
#         if not abspath:
#             page.keep()                 # if folder, create ./.keep file
#             abspath = page.keepabspath  # page.abspath or folder's .keep
#         porcelain.add(os_git, paths=[abspath])
#         porcelain.commit(os_git, '--message=user:{}'.format(page.user.username))
        
#     def rm_and_commit(self, page, abspaths):
#         """ remove files and folders (absolute paths) & commit changes """
#         # -- page is the folder from which the delete form was submitted.
#         page.keep()
#         # delete files & folders explicitly with os.remove() and shutil.rmtree()
#         for abspath in abspaths:
#             if os.path.isdir(abspath):
#                 try:
#                     shutil.rmtree(abspath)      # folders
#                 except:
#                     pass
#             else:
#                 try:
#                     os.remove(abspath)          # files
#                 except:
#                     pass
#         try:
#             # add changes to github repo (TODO: needs more testing!)
#             relpaths = [os.path.relpath(x, os_git).encode('utf8')
#                         for x in abspaths]
#             porcelain.rm(os_git, paths=relpaths)
#         except:
#             pass
#         porcelain.commit(os_git, '--message=user:{}'.format(page.user.username))

#     def log(self, page):
#         """ return revisions and dates of a given file as [(githash, date, author)]"""
#         # The path seems to be picky here - wants not abspath but relative to os_git.
#         relpath = os.path.relpath(page.abspath, os_git).encode('utf8')
#         buffer = io.StringIO()
#         porcelain.log(os_git, paths=[relpath], outstream=buffer)
#         logstring = buffer.getvalue()
#         print_debug(
#             '  dulwich git log for {} is {}'.format(page.abspath, logstring))
#         return parse_porcelain_log(buffer.getvalue())
#    
#     def get_revision(self, page):
#         """ Return content from a git version of a page """
#         # page.revision:     (new) current 4 3 2 1 (old) page.revision
#         # page.githashes     (new) 0       1 2 3 4 (old) if 5 revisions
#         index = len(page.githashes) - page.revision
#         commit_sha = str(page.githashes[index]).encode('utf8')
#         relpath = os.path.relpath(page.abspath, os_git).encode('utf8')
#         return dulwich_get_file_revision(os_git, commit_sha, relpath)

