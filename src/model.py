"""
 model.py
 
 The data class definitons and methods,
 built on the pewee ORM with a sqlite3 database.

 The following tests assumes that the database has been created
 and that populate_database() has been run; see ../database/init_db.

 The script ../bin/umber_test runs these and other tests.

   # Find the people and their role in a course given its name.
   >>> democourse = Course.get(Course.name == 'Demo Course')
   >>> for (username, role) in sorted(democourse.username_to_role.items()):
   ...   user = Person.by_username(username)
   ...   print("{} is {} in {}.".format(user.name, role.name, democourse.name))
   ...
   Jane Q. Doe is student in Demo Course.
   Johnny Smith is student in Demo Course.
   Ted Teacher is faculty in Demo Course.
 
   # Find a person from their username.
   >>> john = Person.get(username='johnsmith')
   >>> print(john.name)
   Johnny Smith

   # test last, first
   >>> john.get_last_first()
   'Smith, Johnny'

   # Change their name.
   >>> john.name = 'John Z. Smith'
   >>> rows_changed = john.save()

   # See the change.
   >>> newjohn = Person.get(username='johnsmith')
   >>> print(newjohn.name)
   John Z. Smith

   # Change it back.
   >>> john.name = 'Johnny Smith'
   >>> rows_changed = john.save()

 See docs/model_notes.txt for more about the database model.

 Jim Mahoney | mahoney@marlboro.edu | MIT License
"""

import os, yaml, re, mimetypes, shutil, random
from functools import reduce
from flask import url_for
from werkzeug.security import generate_password_hash, check_password_hash
from peewee import ( SqliteDatabase, Model, TextField, IntegerField,
                     PrimaryKeyField, ForeignKeyField )
from bs4 import BeautifulSoup
from utilities import ( markdown2html, link_translate, static_url, md5, Time,
                        ext_to_filetype, filetype_to_icon, size_in_bytes,
                        stringify_access, print_debug, clean_access_dict )
from settings import ( os_db, umber_url, protocol, hostname, umber_mime_types,
                       os_root, os_courses, photos_url, url_base,
                       os_default_course, site_course_path, site_home,
                       due_grace_hours )
import gitlocal

db = SqliteDatabase(os_db)

class BaseModel(Model):
    class Meta:
        database = db   # (peewee requires this 'database' name)

    def __repr__(self):
        # e.g. 
        fields = ', '.join(["{}={}".format(x[0],repr(x[1]))
                            for x in list(self.__dict__['_data'].items())])
        return '<{}({}) at 0x{:X}>'.format(self.__class__.__name__,
                                       fields, id(self))

    @classmethod
    def first(cls):
        return cls.select().first()
    
    @classmethod
    def all(cls):
        return list(cls.select().execute())
    
class Person(BaseModel):
    class Meta:
        db_table = 'Person'

    person_id = PrimaryKeyField(db_column='person_id')
        
    username = TextField(unique=True)
    password = TextField()
    name = TextField()
    email = TextField()                
    notes = TextField()

    _by_username = {} # cache
    _admins = None

    @staticmethod
    def from_comma_string(comma_string):
        """ Return people list from a string of usernames e.g. "john,mary" """
        return list(map(Person.by_username, comma_string.split(',')))
    
    @staticmethod
    def searchname(partialname, maxresults=32):
        """ search for a name or username - returning up to a given number """
        people = Person.select().where( \
                    Person.name.contains(partialname) | \
                    Person.username.contains(partialname)) \
                    .order_by(Person.username).limit(maxresults)
        return [p.username for p in people]
    
    @staticmethod
    def create_person(username, name, email, password='', is_admin=False):
        # TODO : restrict legal usernames ...
        #            * prohibit leading '_' (reserved for system)
        #            * lowercase_only? underbar? numbers?
        #            * enforce uniqueness
        with db.atomic():
            (user, created) = Person.get_or_create(username=username)
            if created:
                user.name = name
                user.email = email
                if not password:
                    password = str(random.getrandbits(32))
                user.set_password(password)
                user.save()
            # enroll_site has in it db.atomic() too ...
            # the docs say its OK to nest them.
            Course.enroll_site(user, is_admin=is_admin) 
        return user

    @staticmethod
    def edit_person(username, name, email, password):
        try:
            with db.atomic():
                user = Person.by_username(username)
                user.name = name
                user.email = email
                if password != '':
                    user.set_password(password)
                user.save()
        except:
            print_debug('OOPS : Person.edit_user(username="{}") failed' \
                                .format(username))
                    
    def course_data(self):
        """ return courses that this person is registered in 
            as a dict with keys role,course,url,semester """
        registrations = list(Registration.select(Registration.role,
                                                 Registration.course)
                                         .where(Registration.person == self))
        registrations.sort(key=lambda r: r.course.name)
        registrations.sort(key=lambda r: r.course.start_date, reverse=True)
        return [{'role':r.role.name,
                 'course':r.course.name,
                 'url':r.course.url,
                 'semester':Time(r.course.start_date).semester()}
               for r in registrations if not r.course.name == 'Umber']

    def get_username(self, username):
        return Person.by_username(username)

    def make_admin(self):
        """ Turn this person into a site admin """
        with db.atomic():
            umber = Course.get_site()
            site_registration = Registration.get(course=umber, person=self)
            site_registration.role = Role.by_name('admin')
            site_registration.save()
    
    def works(self, course):
        query = (Work.select()
                     .where( Work.person == self,
                             Work.course == course ))
        return list(query.execute())

    def _save(self):
        """ save to database and invalidate caches """
        try:
            del Person._by_username[self.username]
        except KeyError:
            pass
        Person._admins = None
        self.save()
    
    def set_password(self, passwordtext):
        with db.atomic():
            self.password = generate_password_hash(passwordtext)
            self._save()
        
    def check_password(self, passwordtext):
        return check_password_hash(self.password, passwordtext)

    def get_role(self, course):
        """ Return role of this person in that course """
        if self.username in course.username_to_role:
            return course.username_to_role[self]
        else:
            return Role.by_name('visitor')

    def get_last_first(self):
        names = self.name.split(' ')
        return names[-1] + ', ' + names[0]
        
    # -- Flask-Login methods & tools --

    @staticmethod
    def get_anonymous():
        """ Create and return an anonymous Person """
        # Not saved to database (i.e. save() not called).
        # Not logged in.
        anon = Person(name='anonymous', username='')
        anon.anonymous = True
        return anon
        
    def is_authenticated(self):
        return not self.is_anonymous()
        
    def is_active(self):
        return not self.is_anonymous()
    
    def is_anonymous(self):
        try:
            return self.anonymous
        except:
            return False

    def is_admin(self):
        """ return True if this user is an admin, false otherwise """
        return self.username in Person.admins()

    def get_id(self):
        if self.username == None:
            return str('')
        else:
            return str(self.username)

    def get_photo_url(self):
        return photos_url + '/' + self.username + '.jpg'

    @staticmethod
    def generic_photo_url():
        return photos_url + '/generic_student.png'
    
    @staticmethod
    def by_username(username):
        """ Returns anonymous person if not found """
        if username not in Person._by_username:
            try:
                person = Person.get(username = username)
                #person = Person.select() \
                #               .where(Person.username==username).first()
            except:
                return Person.get_anonymous()
            Person._by_username[username] = person
        return Person._by_username[username]
        
    @staticmethod
    def by_rolename(rolename):
        """ Return list of users who have a given type of registration """
        # ... in any registration record i.e. any course
        return list(Person.select()
                          .join(Registration)
                          .where(Registration.role == Role.by_name(rolename))
                          .execute())
    
    @staticmethod
    def admins():
        """ Return list of administrators """
        if not Person._admins:
            Person._admins = {p.username : True
                              for p in Person.by_rolename('admin')}
        return Person._admins
    
class Course(BaseModel):
    class Meta:
        db_table = 'Course'
        
    course_id = PrimaryKeyField(db_column='course_id')
    
    active = IntegerField()
    assignments_md5 = TextField()
    credits = IntegerField()
    end_date = TextField()
    name = TextField()
    name_as_title = TextField()
    notes = TextField()
    path = TextField(unique=True)
    start_date = TextField()

    _site_course = None  # course for site data

    def prepared(self):        
        """ setup this instance after it's attributes are set """
        # This method is essentially __init__ for these database objects.
        self._set_users()
        self.assignments = self._get_assignments()
        if not self.start_date:
            self.semester = ''
        else:
            self.semester = Time(self.start_date).semester()
        # url without request though that info is also in request
        self.url = umber_url + '/' + self.path
        self.abspath = os.path.join(os_courses, self.path)

    def __getattr__(self, key):
        # Define some attributes (.url, .abspath, .students, ...)
        # when they're needed.
        #
        # June 2019 : there is no "prepared" in python3's peewee;
        # see https://github.com/coleifer/peewee/issues/1479
        # So I need another way to call this after instantiating a Course.
        # See docs.python.org/3/reference/expressions.html#attribute-references;
        # ... I can override __getattr__ to fill 'em in when first accessed.
        if not 'abspath' in self.__dir__():
            self.prepared()
        return self.__getattribute__(key)
        
    def _set_users(self):
        """ define self.students, .faculty, .guests, .username_to_role """
        registrations = list(Registration.select(Registration.person,
                                                 Registration.role)
                                         .where((Registration.course == self)
                                          &  (Registration.status != 'drop')))
        self.students = [reg.person for reg in registrations
                               if reg.role == Role.by_name('student')]
        self.faculty = [reg.person for reg in registrations
                               if reg.role == Role.by_name('faculty')]
        self.guests = [reg.person for reg in registrations
                               if reg.role == Role.by_name('guest')]
        self.students.sort(key=lambda s: s.name)
        self.faculty.sort(key=lambda s: s.name)
        self.username_to_role = {reg.person.username : reg.role
                                 for reg in registrations}
    
    @staticmethod
    def get_all():
        """ Return all but the 'Umber' course, sorted by semester & name """
        result = [c for c in Course.all() if not c.name == 'Umber']
        result.sort(key=lambda c: c.name)
        result.sort(key=lambda c: c.start_date, reverse=True)
        return result

    @staticmethod
    def create_course(name, path, start='', name_as_title='',
                      copyfrom=os_default_course, user=None):
        if name_as_title == '':
            name_as_title = name
        if start == '':
            now = str(Time())
            now_year = now[:4]
            now_month = now[5:7]
            if now_month < '06':
                start = now_year + '-' + '01-01'  # spring
            elif now_month < '09':
                start = now_year + '-' + '06-01'  # summer
            else:
                start = now_year + '-' + '09-01'  # fall
        with db.atomic():
            (course, created) = Course.get_or_create(
                name = name,
                path = path,
                start_date = start,
                name_as_title = name_as_title
                )
        # Create a disk folder for a course by copying
        # files from some other course.
        # (If 'copyfrom' isn't defined, then those course files
        # had better already exist ... which is the case
        # for defaultcourse and democourse.)
        if copyfrom:
            abspath = os.path.join(os_courses, path)
            abscopyfrom = os.path.join(os_courses, copyfrom)
            shutil.copytree(abscopyfrom, abspath)
            # remove the old copied .git folder
            shutil.rmtree(os.path.join(abspath, '.git'), ignore_errors=True)
        gitlocal.init_add_commit(course, user) # initalize its .git folder
        return course
    
    @staticmethod
    def get_site():
        """ return site admin course 'Umber' """
        if not Course._site_course:
            Course._site_course = Course.get(name='Umber')
        return Course._site_course

    @staticmethod
    def create_site():
        """ create site couse 'Umber' """
        # for site resoruces i.e. help files, user id photos etc.
        with db.atomic():
            (sitecourse, created) = Course.get_or_create(
                name = 'Umber',
                name_as_title = 'Umber<div>a course<br>managment<br>system</div>',
                path = site_course_path,
                start_date = '2018-01-01')
        return sitecourse

    def get_shortname(self):
        """ used in html title ; see Page.html_title """
        # TODO : ... something shorter ?
        return self.name

    def is_site(self):
        """ true if this is the site course """
        return self.path == site_course_path
    
    def person_to_role(self, person):
        """ Return role of person in course, or visitor """
        return self.username_to_role.get(person.username,
                                         Role.by_name('visitor'))
    
    def username_is_member(self, username):
        return username in self.username_to_role
    
    def _get_assignments(self):
        return list(Assignment.select() \
                              .where(Assignment.course == self) \
                              .order_by(Assignment.nth))
    def drop(self, user):
        """ Drop user (Person or username) from this course """
        # (Students who are registered may have submitted work.
        # Rather than delete their files and database records,
        # I'm just changing their status to 'drop', and ignoring
        # those people in _set_users
        try:
            person = user
            name = person.name                 # Is this a Person object?
        except AttributeError:
            person = Person.by_username(user)  # No - treat it as a username.
            name = person.name
        if name == 'anonymous' or name == '':
            return "error in drop with user '{}'".format(str(user))
        with db.atomic():
            registration = Registration.get(person=person, course=self)
            registration.status = 'drop'
            registration.date = str(Time())
            registration.save()
        # refresh course data
        self._set_users()
        return "OK, dropped {}.".format(name)

    def get_profile_url(self):
        # site course ends with / ; others don't ... slightly different behavior.
        if self.url[-1] == '/':
            return self.url + 'sys/user'
        else:
            return self.url + '/sys/user'

    def get_home_url(self):
        """ return url for course home page """
        if self.is_site():
            # special case : Umber course home is docs/home,
            #                so that all public stuff can be in docs/*
            home_path = site_home
        else:
            home_path = 'home'
        return os.path.join(self.url, home_path)

    def get_registered(self, rolename=None):
        registrations = list(Registration.select(Registration.person,
                                                 Registration.role)
                                         .where((Registration.course == self)
                                          &  (Registration.status != 'drop')))
        if rolename == 'tutor':
            people = [reg.person for reg in registrations
                      if reg.person.notes == 'tutor']
        elif not rolename:
            people = [reg.person for reg in registrations]
        elif rolename == 'student':
            people = [reg.person for reg in registrations
                      if (reg.role.name == rolename
                          and reg.person.notes != 'tutor')]
        else:
            people = [reg.person for reg in registrations
                      if reg.role.name==rolename]
        people.sort(key=lambda p: p.get_last_first())
        return people

    def email_everyone_html(self):
        return "mailto:" + ','.join([p.email for p in self.get_registered()])
    
    def has_username(self, username):
        return username in self.username_to_role
    
    def get_faculty_data(self):
        """ return {'email', 'name'} of faculty """
        return [{'email':person.email, 'name':person.name}
                for person in self.faculty]

    def grade_data_list(self, student):
        """ return student's view grade list for templates/grades.html """
        # See the description below for the faculty grid.
        result = list(self.get_assignments_with_extras())
        for ass in result:
            # Hmmm - not sure why this needs .person_id here, but errors without.
            # Maybe something about how the jinja2 template treats variables?
            # Or because the assignment has had its fields modified??
            ass.work = ass.get_work(student.person_id)
            (grade, css_grade) = ass.work.get_grade_css(faculty_view=True)
            ass.work_grade = grade
            ass.work_css_grade = "grade-{}".format(css_grade)
            ass.duedate = Time(ass.due).assigndate()
        return result
    
    def grade_data_grid(self):
        """ return faculty's grade grid for templates/grades.html """
        # Returned data is list of dicts, one per student.
        # Each student dict includes list of student works, one per assignment.
        # The grade will be shown as
        #    '…'          if not submitted and not yet due
        #    'overdue'    if not submitted and past due date
        #    'ungraded'   if submitted and not graded
        #    work.grade   if submitted and graded
        #
        # The grade css class is "grade-*"
        # where * is one of (green,darkgreen,darkred,red,black)
        #   for faculty viewing the color is :
        #     red          overdue : due > today and not submitted
        #     brown        faculty modified date > student seen date
        #     darkgreen    student modified date > faculty seen date
        #     green        ungraded : student has submitted; faculty hasn't graded
        #     black        none of above
        #   for student viewing the color is : 
        #     brown        ungraded : student has submitted; faculty hasn't graded
        #     brown        student modified; faculty hasn't seen
        #     dark green   faculty modified; student hasn't seen
        #     green        overdue : due > today and not submitted
        #     black        none of above
        #
        # The basic idea of the colors is that
        #    green-ish means the viewer should respond (i.e. "go")
        #    red-ish   means that the other person should do something
        #              (i.e. a problem)
        #
        result = []
        for stud in self.students:
            # skip grade line for student if their .notes is 'tutor'
            # ... though I don't have a GUI to set that property yet.
            if stud.notes == 'tutor': continue
            works = []
            for ass in self.assignments:
                work = ass.get_work(stud)
                (grade, css_grade) = work.get_grade_css(faculty_view=True)
                works.append({'url':        work.get_url(),
                              'css_grade':  'grade-{}'.format(css_grade),
                              'grade':      grade,
                              'id':         work.work_id
                              })
            result.append({'email': stud.email,
                           'name' : stud.name,
                           'works': works
                           })
        return result
    
    def get_assignment_by_nth(self, nth):
        """ Return nth assignment in this course """
        try:
            return Assignment.select() \
                             .where(Assignment.course == self, \
                                    Assignment.nth == nth) \
                             .first()
        except:
            return None
                              
    def update_assignments(self, assignments_data):
        """ Update course assignments from 
            a dict of assignments_data[nth][name, due, blurb] """
        # Note: passed argument is *not* made up of Assignment objects.
        # Note: this is designed to update *all* assignments.
        db_assignments = {a.nth : a for a in self._get_assignments()}
        with db.atomic():
            for nth in assignments_data:
                if nth not in db_assignments:
                    (db_assignments[nth], status) = Assignment.get_or_create(
                        course=self, nth=nth)
                db_assignments[nth].name = assignments_data[nth]['name']
                duedate = assignments_data[nth]['due']
                db_assignments[nth].due = str(Time.parse(duedate))
                new_blurb = assignments_data[nth]['blurb']
                old_blurb = db_assignments[nth].blurb
                #print_debug(f" debug update_assignments : '{duedate}'")
                #print_debug(f"   md5(new_blurb) = '{md5(new_blurb)}'")
                #print_debug(f"     new_blurb = '{new_blurb}' ")
                #print_debug(f"   ass.blurb_hash  = '{db_assignments[nth].blurb_hash}'")
                #print_debug(f"     ass.blurb  = '{old_blurb}' ")
                #print_debug(f"   new == old ? {new_blurb == old_blurb}")
                if md5(new_blurb) != db_assignments[nth].blurb_hash: # is this changed?
                    db_assignments[nth].blurb = new_blurb             # yes: update it
                    db_assignments[nth].blurb_hash = md5(new_blurb)
                    db_assignments[nth].blurb_html = markdown2html(new_blurb)
                    #print_debug("   updating cache ")
                #else:
                    #print_debug("   NOT updating cache ")
                db_assignments[nth].save()
        self.assignments = self._get_assignments()

    def get_assignments_with_extras(self):
        """ Return list of assignments in this course with extra info """
        # ... i.e. prepare the data for html display
        now = Time()
        # print(" now = " + str(now))
        if len(self.assignments) == 0:
            self.assignment_nth_plus1 = 1
        else:
            self.assignment_nth_plus1 = self.assignments[-1].nth + 1
        for ass in self.assignments:
            duedate = Time(ass.due)
            if duedate < now:
                #print(" PAST : duedate = " + str(duedate))
                ass.dateclass = 'assign-date-past'
            else:
                #print(" FUTURE : duedate = " + str(duedate))
                ass.dateclass = 'assign-date'
            ass.date = duedate.assigndate()         # for assignment list display
            ass.ISOdate = duedate.assignISOdate()   # ditto
        return self.assignments
    
    def nav_page(self, user):
        """ return course's navigation page """
        # TODO: put this in a "try" and do something reasonable if it fails.
        #       (otherwise, pages in courses without sys/navigation.md will crash.)
        # TODO: should this be cached to self._nav_page ?
        # (Need it for both displaying and editing course's navigation page.)
        return Page.get_from_path(os.path.join(self.path,
                            'sys', 'navigation.md'), user=user)
    
    def nav_html(self, user, page):
        """ Return html for course's navigation menu 
            for a given user & a given page """
        return self.nav_page(user).nav_content_as_html(page)

    @staticmethod
    def enroll_site(person, datestring=None, is_admin=False):
        """ enroll a person in the site course """
        # All users should be in this course.
        if not datestring:
            datestring = str(Time())
        site_course = Course.get_site()
        if is_admin:
            site_role = Role.by_name('admin')
        else:
            site_role = Role.by_name('member')
        with db.atomic():
            (reg, created) = Registration.get_or_create(
                person = person,
                course = site_course)
            if created or is_admin:   # update role & date
                reg.role = site_role
                reg.date = datestring
            reg.status = ''
            reg.save()
        site_course._set_users()

    def make_student_work_folders(self):
        for person in self.students:
            student_abspath = os.path.join(self.abspath,
                                           'students', person.username)
            if not os.path.exists(student_abspath):
                Page.new_folder(student_abspath, user=person,
                                accessdict= {'read':person.username,
                                         'write':person.username})
            work_abspath = os.path.join(student_abspath, 'work')
            if not os.path.exists(work_abspath):
                Page.new_folder(work_abspath, user=person)
                    
    def enroll(self, person, rolename, datestring=None, create_work=False):
        """ Enroll a person in this course with this role. """
        # If there is an existing registration for the course&person, modify it.
        # Also enroll this person in the site couse if they aren't already
        # and if this isn't the site course itself.
        # Optionally create their work folder (if it doesn't already exist)
        if not datestring:
            datestring = str(Time())
        with db.atomic():
            (reg, created) = Registration.get_or_create(
                person = person,
                course = self)
            reg.role = Role.by_name(rolename)
            reg.status = ''     # if re-enrolling would have been 'drop'
            reg.date = datestring
            reg.save()
            if not self.name == 'Umber':
                Course.enroll_site(person, datestring=datestring)
        if create_work:
            # Create folder for student work within the course folder.
            # The absolute path for their student work folder is
            # e.g. course/students/johnsmith/    with its .access.yaml
            #   &  course/students/johnsmith/work/
            student_abspath = os.path.join(self.abspath,
                                           'students', person.username)
            Page.new_folder(student_abspath, user=person,
                            accessdict= {'read':person.username,
                                         'write':person.username})
            work_abspath = os.path.join(student_abspath, 'work')
            Page.new_folder(work_abspath, user=person)
        # refresh students
        self._set_users()

class Page(BaseModel):

    #  --- path, filename, url definitions ---
    #  With settings on my laptop development machine as
    #    os_courses    /Users/mahoney/academics/umber/courses
    #  then for the 'notes/week1' file within a course at 'fall/math' ,
    #  the parts are
    #    url:  http://127.0.0.1:5000/  umber    /  fall/math / notes/week1
    #          protocol  hostname   url_base    path...................
    #    file: /Users/mahoney/academics/umber/courses / fall/math / notes/week1
    #          os_courses                               path...................
    #  Following python's os.path phrasing, other terms used here are
    #    basename     last word in address (same as os.path.basename)
    #    abspath      e.g. /Users/mahoney/.../fall/math/notes/week1
    #    dirname      e.g. /Users/mahoney/.../fall/math/notes
    #  This url would have in its flask request object the attributes
    #    request.url_root        'http://localhost:8090/'
    #    request.path            '/umber/fall/math/notes/week1'
    #
    # Note that Page.path (e.g. fall/math/notes/week1)
    # does not have a leading slash or contain the url_base,
    # while request.path (e.g. /umber/fall/math/notes/week1) does.
    #
    # The Page object will also contain various extra data 
    # that isn't stored in the sql database but is instead
    # pulled from the filesystem.

    class Meta:
        db_table = 'Page'

    # Each course has some sys/* pages which get special treatment.
    # Also here are site/sys/* pages for editing users and courses,
    # which are only accessible within the 'site' course.
    system_pages = ('assignments', 'navigation', 'error', 'folder',
                    'grades', 'roster', 'user', 'users', 'course',
                    'courses', 'registration', 'newuser', 'newcourse')
    editable_system_pages = ('assignments', 'navigation',
                             'grades', 'user', 'course')
        
    page_id = PrimaryKeyField(db_column='page_id')

    html = TextField()
    html_lastmodified = TextField()
    notes = TextField()
    path = TextField(unique=True)
    
    course = ForeignKeyField(model=Course,
                             db_column='course_id',
                             to_field='course_id')

    _mime_types = None

    @staticmethod
    def new_folder(abspath, accessdict=None, user=None):
        """ Create a new folder with the given abspath.
            Add it into the github repo. 
            Optionally create its .access.yaml file. """
        if os.path.exists(abspath):
            # bail without doing anything of this already exists
            # print_debug(' new_folder {} already exists '.format(abspath))
            return None
        try:
            os.makedirs(abspath)  # makes intermediate folders if need be.
        except:
            # bail with error message if the OS system won't do it.
            print_debug(' os.makdir("{}") failed '.format(abspath))
            return None
        # Add an empty .keep file in this new folder,
        # as a workaround to force git to include this new folder.
        # (Git pays attention to files, not folders.)
        open(os.path.join(abspath, '.keep'), 'w').close() # unix 'touch'
        # Create the new folder object.
        path = os.path.relpath(abspath, os_courses)
        folder = Page.get_from_path(path, user=user)
        if accessdict:
            # don't do a git commit here - wait to do whole folder 
            folder.write_access_file(accessdict, do_git=False)
        gitlocal.add_commit(folder)
        return folder
    
    @classmethod
    def get_from_path(cls, path, revision=None, action=None, user=None):
        """ Get or create a Page and set up all its internal data 
            i.e. course, file info, user permissions, etc """
        (page, iscreated) = Page.get_or_create(path=path)
        if user == None:
            user = Person.get_anonymous()
        page.user = user
        page.action = action
        page.revision = revision
        page._setup_file_properties()           # sets page.is_file etc
        page.gitpath = os.path.join(os_courses, page.path_with_ext)
        page.login_google_url = url_for('login_google', pagepath=path)
        page.course = page.get_course()
        try:
            if page.course.page_error:
                ### Unexpected (to me anyway) behavior here :
                ###     page.course = None
                ###     if page.course:        # This throws an error!
                ###        ...
                ### Apparently the peewee database code has put hooks into
                ### the Page object to do tricky stuff for "page.course",
                ### seems to drop into peewee and complain.
                ### I'm avoiding this by returning the Umber site course
                ### but with a .page_error attribute set.
                ### In umber.py this will turn the request into 404 not found.
                return page     
        except AttributeError:
            # .page_error field not set; keep going.
            pass
        page.relpath = page._get_relpath()
        page._setup_sys()                   # do this before .get_access()
        page.access = page.get_access()     # gets .access.yaml property.
        page._setup_user_permissions()      # sets page.can['read'] etc
        if revision or action=='history':
            page._setup_revision_data()     # sets page.history etc
        page._setup_attachments()           # sets .has_attachments
        page._setup_work()                  #
        page.html_title = page.get_html_title()
        return page

    def get_html_title(self):
        """ Return string for the <title></title> html tag. """
        try:
            return self.course.get_shortname() + ' : ' + self.relpath
        except:
            return self.path
    
    def get_gitpath(self, abspath=None):
        """ Return file path of page (or abspath file) relative to course path,
            including file extension if any """
        # This abspath option is used in gitlocal.py and umber.py:ajax_upload ;
        # for attachments the page is not the upload file.
        _abspath = self.abspath if abspath==None else abspath
        return os.path.relpath(_abspath, self.course.abspath)
    
    def _get_relpath(self):
        """ Return path of page relative to course path, 
            e.g. notes/home for path=demo/notes/home in course 'demo' """
        # self.course must be already set.
        return os.path.relpath(self.path, self.course.path)
    
    def attachments_folder(self):
        return self.abspath.replace(self.ext, '.attachments')
    
    def _setup_attachments(self):
        if self.is_file and self.ext == '.md':
            attach_dir = self.attachments_folder()
            if os.path.exists(attach_dir) and os.path.isdir(attach_dir):
                self.attachments = self.children(abspath=attach_dir)
            else:
                self.attachments = []
            self.has_attachments = len(self.attachments) > 0
        else:
            self.attachments = []
            self.has_attachments = False
            
    def _setup_work(self):
        """ see if this is a students/<name>/work/<number> student work page; 
            define .is_work and .work, set up .work for html display,
            update 
        """
        # print(' _setup_work : relpath = {}'.format(self.relpath))
        m = re.match(r'students/(\w+)/work/(\d+)(\?.*)?', self.relpath)
        if m:
            now = Time()
            self.is_work = True
            (work_username, work_nth, ignore) = m.groups()
            work_nth = int(work_nth)
            self.work_person = Person.by_username(work_username)
            self.work_assignment = self.course.get_assignment_by_nth(work_nth)
            self.work = self.work_assignment.get_work(self.work_person)
            duedate = Time(self.work_assignment.due)
            self.work_due = duedate.assigndatedetail()
            # ... but give students a extra grace period of a few hours
            # before marking things as "late";
            # this let's me get "end of day" to something reasonable,
            # without changing server timezone
            duedate.arrow = duedate.arrow.shift(hours=due_grace_hours)
            if self.work.submitted:
                submitdate = Time(self.work.submitted)
                self.work_submitted = submitdate.assigndate()
                self.work_is_late = submitdate > duedate
            else:
                self.work_submitted = ''
                self.work_is_late = now > duedate
            self.work_grade = self.work.grade
            # update *_seen fields in the database
            # TODO : think about whether there's a better
            #        transactional way to update the database here.
            if self.user_role.name == 'faculty':
                self.work.faculty_seen = str(now)
                self.work.save()
            if self.user.username == work_username:
                self.work.student_seen = str(now)
                self.work.save()
        else:
            self.is_work = False
            #self.work = None
            #self.work_assignment = None
            #self.work_person = None
            #self.work_due = ''
            #self.work_submitted = ''
            #self.work_is_late = False
            #self.work_grade = ''
    
    def _setup_sys(self):
        """ define .is_sys.
            if it is, also define .sys_template, ./sys_edit_template """
        # If relpath is 'sys/assignments', then is_sys will be true,
        # the template will be 'umber/sys/assignments.html'
        # and the edit template will be 'umber/sys/edit_assignments.html',
        # (and the access permissions will be in the first line of the template.)
        self.is_sys = self.relpath[:4] == 'sys/'
        # -- default values for sys templates for all pages --
        if self.is_sys:
            which = self.relpath[4:]
            if which == '':
                which = 'folder'
            if which not in Page.system_pages:
                which = 'error'
            self.sys_template = 'sys/' + which + '.html'
            if which in Page.editable_system_pages:
                self.sys_edit_template = 'sys/edit_' + which + '.html'
            else:
                self.sys_edit_template = 'sys/editerror.html'

    def get_course(self):
        """ return this page's course """
        # And if there is no course for this page,
        # return the site course but also set an error within it.
        #
        # extract path pieces e.g. ['demo', 'home']
        path_parts = self.path.split('/')
        # build partial paths e.g. ['demo', 'demo/home']
        # (stackoverflow.com/questions/13221896/python-partial-sum-of-numbers)
        paths = reduce(lambda x,y: x + [x[-1]+'/'+y],
                       path_parts[1:], path_parts[0:1])
        # build peewee's "where condition" to find matching courses.
        condition = Course.path
        for c in paths:
            condition = condition | Course.path % c
        # Get list of matching courses from database.
        # Choose the one with the longest path,
        # if more than on was found ...
        # which would only happen for courses directories
        # embedded within another course, which shouldn't happen.
        # TODO: make sure to test for that issue during new course creation
        query = Course.select().where(condition)
        courses = list(query.execute())
        #
        if courses:
            return max(courses, key=lambda c: len(c.path))
        else:
            # Couldn't find a course for that page, so return
            # the default course with a flag indicating the error.
            umber = Course.get_site()
            umber.page_error = True
            return umber

    def write_access_file(self, accessdict, do_git=True):
        """ Given an access dict from user input e.g. 
            {'read':'students', 'write':['faculty','bob']} ,
            write it to a .access.yaml file, and return its abspath. """
        assert self.is_dir  # this page should be a folder
        accesspath = os.path.join(self.abspath, '.access.yaml')
        accessfile = open(accesspath, 'w')     # open or create
        # replace yaml permissions
        # (yaml.dump turns u'string' into ugly stuff so I convert to str().
        accessfile.write(yaml.dump(clean_access_dict(accessdict)))
        accessfile.close()
        if do_git:
            # I've left an option to avoid this to handle
            # the case of a new folder efficiently, since
            # we can in that case commit the whole folder in one go
            # after this .access.yaml is created.
            gitlocal.add_commit(self)
        return accesspath
    
    def get_access(self):
        """ Return .access dict from .access.yaml in an enclosing folder 
            or from the first line of a sys_template
        """
        # e.g. {'read': ['janedoe', 'johnsmith'], 'write': 'faculty'}
        # default if we don't find it.
        #access_dict = {'read':'all', 'write':'faculty'}  
        if self.is_sys:
            ## navigation is a special case : since it's a faculty editable file,
            ## I'll fill it it manually and not require that it have
            ## the {# #} first line.
            if self.relpath == 'sys/navigation' or \
               self.relpath == 'sys/navigation.md':
                access_dict = {'read':'member', 'write':'faculty'}
            else:
                ## all other system files have an access spec as their first line
                ## e.g.  {# {'read':'all', 'write':'faculty' #}
                template = os.path.join(os_root, 'templates', self.sys_template)
                firstline = open(template).readline()
                try:
                    access_dict = eval(firstline.replace('{#','').replace('#}',''))
                except:
                    # something fairly safe as a fall-back
                    access_dict = {'read':'faculty', 'write':'faculty'}
        else:
            if self.is_dir:
                abspath = self.abspath
            else:
                abspath = os.path.dirname(self.abspath)
            while len(abspath) >= len(os_courses):
                accesspath = os.path.join(abspath, '.access.yaml')
                if os.path.exists(accesspath):
                    accessfile = open(accesspath)
                    # see https://msg.pyyaml.org/load
                    access_dict = yaml.full_load(accessfile)
                    accessfile.close()
                    if type(access_dict) == type({}):
                        # OK, we found an access dict, so stop here.
                        break
                abspath = os.path.dirname(abspath) # i.e. "cd .."
        if 'read' not in access_dict:
            access_dict['read'] = ''
        if 'write' not in access_dict:
            access_dict['write'] = ''
        # clean up for display :
        self.read_access = stringify_access(access_dict['read'])
        self.write_access = stringify_access(access_dict['write'])
        return access_dict

    def _setup_user_permissions(self):
        """ Set page.can['read'], page.can['write'],
                page.user_role, page.user_rank 
                from page.user, page.access, and page.course """
        # Note that admins who are faculty in a given course
        # will have a displayed role of 'faculty' in that course
        # but will have admin access to nav menus etc.
        assert self.course != None  # call self.set_course() first.
        assert self.access != None  # call self.set_access() first.
        assert self.user != None    #
        self.user_role = self.course.person_to_role(self.user)
        self.user_rank = self.user_role.rank
        
        if self.user_role.name in ('faculty', 'admin') and not self.is_sys:
            # faculty & admin can read or write anything 
            # ... but not system pages - I don't want 'edit' tab on all pages.
            self.can = {'read': True, 'write': True}
            return
        
        if self.user.is_admin():
            # Let site admins do what they want in any course.
            # Change their display name to 'admin' if it isn't 'faculty'.
            # i.e. leave 'faculty' or 'student' display names as is.
            self.user_rank = Role.by_name('admin').rank
            if self.user_role.name != 'faculty':
                self.user_role = Role.by_name('admin')
    
        self.can = {'read':False, 'write':False} # default is deny access
        for permission in ('read', 'write'):
            yaml_rights = self.access[permission]
            access_needed = 10  # i.e. more than anyone has by default
            # can be list e.g. ['faculty', 'bob'] or string 'students'
            if type(yaml_rights) == type(''):
                yaml_rights = [ yaml_rights ]
            for name_or_role in yaml_rights:
                if name_or_role == self.user.username:
                    self.can[permission] = True
                    break
                elif name_or_role in Role.name_alias:
                    access_needed = min(access_needed, \
                                        Role.by_name(name_or_role).rank)
            if self.user_rank >= access_needed:
                self.can[permission] = True

    def get_mimetype(self):
        """ Return e.g. 'image/jpeg' for '.jpg' file """
        if not Page._mime_types:
            mimetypes.init()
            Page._mime_types = mimetypes.types_map.copy()
            for key in umber_mime_types:
                Page._mime_types[key] = umber_mime_types[key]
        if self.ext == '':
            return 'text/plain'
        return Page._mime_types.get(self.ext, 'application/octet-stream')

    def children(self, abspath=''):
        """ return page for each file or folder below this folder """
        result = []
        if abspath == '':
            abspath = self.abspath
        try:
            path = os.path.relpath(abspath, os_courses)
            for name in sorted(os.listdir(abspath)):
                if name[0] == '.':  # skip invisible files e.g. .access.yaml
                    continue
                result.append(Page.get_from_path(os.path.join(path, name), user=self.user))
        except OSError:  # i.e. if abspath isn't a directory.
            pass
        return result

    def icon_url(self):
        """ return url for icon for this file type """
        return static_url(filetype_to_icon[self.filetype])

    def _setup_revision_data(self):
        """ read and store within page the git file revision data """
        # The log is a list of tuples [(revision, date, author), ...]
        log = gitlocal.get_history(self)  
        if len(log) == 0:
            link = self.url
            date = self.lastmodified.daydatetimesec()
            author = ''
            self.githashes = tuple()
            self.history = ([link, 'current', date, author], )
            self.revision_date = date
            self.revision_commit = ''
            self.revision_prev_url = ''
            self.revision_next_url = ''
            self.revision_count = 1
            self.revision = None  # No git revision stored.
        else:
            self.githashes = tuple((githash for (githash, date, author) in log))
            self.history = [None] * len(log)
            for i in range(len(log)):
                #   say len(log) == 4 
                #     nth =>  (new) current 3 2 1 (old)
                #     i   =>        0       1 2 3 (old)
                if i == 0:
                    nth = 'current'
                    url = self.url
                else:
                    nth = len(log) - i
                    url = self.url + '?revision={}'.format(nth)
                #  history =>           0:url  1:nth  2:date     3:author
                self.history[i] = tuple((url,   nth,   log[i][1], log[i][2]))
            self.revision_count = len(log)
            self.revision_date = self.history[0][2]
            if self.revision:
                self.revision = int(self.revision)
                index = self.revision_count - self.revision
                self.revision_date = self.history[index][2]
                self.revision_commit = self.githashes[index]
                self.revision_next_url = self.url + '?revision={}'.format(
                    min(self.revision + 1, len(log)))
                self.revision_prev_url = self.url + '?revision={}'.format(
                    max(self.revision - 1, 1))

    def _setup_file_properties(self):
        """ given self.path, set a bunch of information about the file
            including self.absfilename, self.exists, self.is_file, self.is_dir,
            self.lastmodified, self.breadcrumbs
         """
        self.abspath = os.path.join(os_courses, self.path)
        self.path_with_ext = self.path  # default, unless modified below
        if not os.path.exists(self.abspath):
            for ext in ['.md', '.html']:
                if ext == '.md' and os.path.exists(self.abspath + ext):
                    self.abspath = self.abspath + ext
                    self.path_with_ext = self.path + ext
        (ignore, self.ext) = os.path.splitext(self.abspath)
        self.exists = os.path.exists(self.abspath)
        #print_debug(f'debug _setup_file_properties : path={self.path} exists={self.exists} ')
        if not self.exists and self.ext == '':
            # creating a new file, so make it a .md markdown file
            self.ext = '.md'
            self.abspath += '.md'
        self.name_with_ext = os.path.split(self.abspath)[-1]
        if self.ext == '':
            self.name = self.name_with_ext
        else:
            self.name = self.name_with_ext[: - len(self.ext) ]
        # self.name_underlined = self.name + '\n' + '='*len(self.name)
        self.path_no_name = self.path[: - len(self.name) ]
        self.is_file = os.path.isfile(self.abspath)
        self.is_dir = os.path.isdir(self.abspath)
        if self.exists:
            stat = os.stat(self.abspath)
            #print_debug(f'debug _setup_file_properties : stat={str(stat)}')
            self.lastmodified = Time(stat.st_mtime)
            if self.is_dir:
                self.size = None
                self.filetype = 'directory'
                self.name_with_ext += '/'
            elif self.is_file:
                self.size = stat.st_size
                self.filetype = ext_to_filetype.get(self.ext, 'unknown')
            else:
                self.size = None
                self.filetype = 'unknown'
        else:
            self.lastmodified = None
            self.size = None
        # -- build url links for page breadcrumbs --
        url_list = [url_base] + self.path.split('/')
        urlsofar = protocol + hostname 
        self.breadcrumbs = '<a href="{}">{}</a>'.format(urlsofar, urlsofar)
        while url_list:
            pathpart = '/' + url_list.pop(0)
            urlsofar += pathpart
            self.breadcrumbs += '&nbsp;' + '<a href="{}">{}</a>'.format(
                urlsofar, pathpart)
        self.url = umber_url + '/' + self.path
        self.url_for_print_version = self.url + '?print=1'
        self.bytesize = size_in_bytes(self.size)

    def revision_content_as_html(self):
        content = gitlocal.get_revision(self)
        html = markdown2html(content)
        html_with_links = link_translate(self.course, html)
        return html_with_links

    def content(self):
        """ Return file or github (revision) data for a page """
        # python3 gotchas:
        #  for text, I convert to a python3 string (utf8)
        #  but for other (i.e. binary) data, I leave as python3 bytes
        if self.exists and self.is_file:
            if self.revision:
                text = gitlocal.get_revision(self)
            else:
                with open(self.abspath, 'rb') as _file:
                    text_bytes = _file.read()
                    try:
                        text = text_bytes.decode('utf8')  
                    except:
                        text = text_bytes   # e.g. *.png files
        else:
            text = ''
        #print_debug(" page.content : page.action = '{}'".format(page.action))
        return text

    def write_content(self, new_content):
        """ Write new data to page's file; return number of bytes written """
        if self.can['write']:  # shouldn't get here without this anyway
            with open(self.abspath, 'wb') as _file:
                # open as binary ... need to write bytes.
                try:
                    new_bytes = new_content.encode('utf8')
                except:
                    new_bytes = new_content
                bytes_written = _file.write(new_bytes)
        return bytes_written

    def content_as_html(self):
        """ Return file contents as html. """
        # This also handles revisions since self.content() does.
        if not self.exists:
            return ''
        elif self.ext == '.md':
            # I'm caching the html version of .md pages in the sql database
            # (for the current version)
            # checking to see if the cache is stale with
            # the file's lastmodified and a sql db html_lastmodified fields.
            #print_debug(f" debug content_as_html cache")
            #print_debug(f"   lastmodified='{self.lastmodified}' ; " + \
            #            f"html_lastmodified='{self.html_lastmodified}'")
            if self.revision:
                content = self.content()  # pull from git repo
                raw_html = markdown2html(content)
                self.html = link_translate(self.course, raw_html)
                self.html_lastmodified = str(self.lastmodified)
            elif str(self.lastmodified) != self.html_lastmodified:
                 #print_debug(f"   updating {self.path}")
                with db.atomic():
                    content = self.content()  # pull from file
                    raw_html = markdown2html(content)
                    self.html = link_translate(self.course, raw_html)
                    self.html_lastmodified = str(self.lastmodified)
                    self.save()
            #else:
                #print_debug(f"   using cache {self.path}")
                # cache : just use .html already read from sql
            html = self.html
        else:
            # Not markdown, so send the file (txt, html, ...) as is.
            html = self.content() # from file or git repo
        return html

    def action_query(self):
        """ Return empty string or '&action=edit' if editing """
        if self.action == 'edit':
            return '&action=edit'
        else:
            return ''
    
    def nav_content_as_html(self, page):
        """ Return authorized parts of html & markdown at html . """
        # Here self is the navigation.md page.
        #   TODO: unlinkify current page
        #   TODO: This implementation is pretty ugly.
        #         Perhaps just do this explicitly without BeautifulSoup?
        #         And make some tests ...
        # Each course has a menu navigation page which is a mixture of html
        # and markdown, including access tags that look like this :
        #    <div access='student'>
        #    ...
        #    </div>
        # This method converts the content of that file to html,
        # keeping only the parts that this user is allowed to see.
        parser = BeautifulSoup(self.content(), 'html.parser')
        for role in list(Role.name_rank.keys()):
            divs = parser.find_all('div', access=role)
            if self.user_rank < Role.by_name(role).rank:
                for div in divs:
                    div.extract() # remove this div from its parent parser
        insides = []
        marker = '.~*#!#*~.'  # something that won't be in the html.
        for divm in parser.find_all('div', markdown=1):
            contents = ''.join(divm.stripped_strings)
            mstring = markdown2html(contents)
            insides.append(mstring)
            divm.string = marker
        html = str(parser) # convert beautiful soup object to formatted unicode
        while insides:
            inside = insides.pop(0)
            html = html.replace(marker, inside, 1)
        html = link_translate(self.course, html)
        # If the current page is one of the links in the nav menu,
        # that link should be unlinkified ... which I'm doing
        # with another (ugh) pass through BeautifulSoup,
        # now that markdown has run.
        # -------------
        # TODO do the right thing for file.md, file.html,
        # and folder ; currently only "file" and "folder/" will work
        # in the nav markdown; the other non-canonical with redirectrs won't.
        # (So check other options in a loop, eh?)
        parser = BeautifulSoup(html, 'html.parser')
        anchor = parser.find('a', href=page.url)
        if anchor:
            span = parser.new_tag('span')
            span['class'] = 'thispage'
            span.string = anchor.string
            parser.find('a', href=page.url).replace_with(span)
        html = str(parser)
        return html
    
class Assignment(BaseModel):
    class Meta:
        db_table = 'Assignment'

    assignment_id = PrimaryKeyField(db_column='assignment_id')
    
    nth = IntegerField(null=False, unique=True)
    active = IntegerField()
    blurb = TextField()
    blurb_hash = TextField()
    blurb_html = TextField()
    due = TextField(null=True)
    name = TextField()
    notes = TextField()
    
    course = ForeignKeyField(model=Course,
                             db_column='course_id',
                             to_field='course_id')

    def get_url(self):
        return '{}/sys/assignments#{}'.format(self.course.url, self.nth)

    def name_smaller(self):
        """ return html version of assignment name with <br> instead of spaces """
        return self.name.replace(' ', '<br>')

    def get_work(self, person):
        """ Return Work for this assignment by given student """
        # i.e. work = assignment.get_work(student)
        with db.atomic():
            (work, created) = Work.get_or_create(assignment = self,
                                                 person = person)
            if created:
                work.grade = ''     # | I would have expected this to be 
                work.notes = ''     # | created with the sql defaults ...
                work.submitted = '' # | but apparently not.
                work.student_modified = ''
                work.faculty_modified = ''
                work.student_seen     = ''
                work.faculty_seen     = ''
                work.page = 0
                work.save()
        return work
    
class Role(BaseModel):
    class Meta:
        db_table = 'Role'

    role_id = PrimaryKeyField(db_column='role_id')
    
    name = TextField()
    rank = IntegerField()

    name_rank = {'admin': 5,
                 'faculty': 4,
                 'student': 3,
                 'member': 2,
                 'visitor': 1
                 }
    name_alias = {'admin':           'admin',
                  'administrator':   'admin',
                  'faculty':         'faculty',
                  'student':         'student',
                  'students':        'student',
                  'class':           'student',
                  'guests':          'member',
                  'guest':           'member',
                  'member':          'member',
                  'all':             'visitor',
                  'any':             'visitor',
                  'visitor':         'visitor'
                  }

    _cache = {}

    @staticmethod
    def by_name(name):
        if not name in Role.name_rank:
            if name in Role.name_alias:
                name = Role.name_alias[name]
            else:
                name = 'visitor'
        if not name in Role._cache:
            Role._cache[name] = Role.get(name=name)
        return Role._cache[name]

    @staticmethod
    def unalias(alias):
        """ Convert alias to its standard role name. """
        return Role.name_alias[alias]

    @staticmethod
    def create_defaults():
        with db.atomic():
            for (name, rank) in list(Role.name_rank.items()):
                Role.get_or_create(name=name, rank=rank)
                
class Registration(BaseModel):
    class Meta:
        db_table = 'Registration'
        
    registration_id = PrimaryKeyField(db_column='registration_id')
    
    credits = IntegerField()
    date = TextField(null=True)
    grade = TextField()
    midterm = TextField()
    status = TextField()

    course = ForeignKeyField(model=Course,
                             db_column='course_id',
                             to_field='course_id')
    person = ForeignKeyField(model=Person,
                             db_column='person_id',
                             to_field='person_id')
    role = ForeignKeyField(model=Role,
                           db_column='role_id',
                           to_field='role_id')
        
class Work(BaseModel):
    class Meta:
        db_table = 'Work'

    work_id = PrimaryKeyField(db_column='work_id')
                
    grade = TextField()
    notes = TextField()
    submitted = TextField()
    student_modified = TextField(db_column='student_modified')
    student_seen = TextField(db_column='student_seen')
    faculty_modified = TextField(db_column='faculty_modified')
    faculty_seen = TextField(db_column='faculty_seen')

    assignment = ForeignKeyField(model=Assignment,
                                 db_column='assignment_id',
                                 to_field='assignment_id')
    person = ForeignKeyField(model=Person,
                             db_column='person_id',
                             to_field='person_id')
    page = ForeignKeyField(model=Page,
                           db_column='page_id',
                           to_field='page_id')

    @staticmethod
    def edit_grades(id_grade_dict):
        """ id_grade_dict is web form with some {'work_<id>':new_grade}
            extract id's & change grades """
        # the dict also has other keys i.e. 'submit_work'; ignore them.
        try:
            with db.atomic():
                for key in id_grade_dict:
                    if key[:5] == 'work_':  
                        id = int(key[5:])
                        work = Work.get(work_id=id)
                        # See get_grade_css for special grades ..., 
                        # The special grades "...", "overdue', 'ungraded'
                        # are created when the actual grade is not set yet.
                        grade = id_grade_dict[key]
                        if grade in ('…', '...', 'overdue', 'ungraded'):
                            grade = ''
                        work.grade = grade
                        work.save()
        except:
            print_debug('OOPS : Work.edit_grades(id_grade_dict="{}") failed' \
                                .format(id_grade_dict))
    
    def get_url(self):
        # Also see templates/assignments.html
        return '{}/students/{}/work/{}.md'.format(self.assignment.course.url,
                                                  self.person.username,
                                                  self.assignment.nth)

    def get_grade_css(self, faculty_view):
        css_class = 'black'      # the default
        #
        duedate = Time(self.assignment.due)
        duedate.arrow = duedate.arrow.shift(hours=due_grace_hours)
        now = Time()
        before_due_date = now < duedate
        #
        # Set blank times to '1901' to avoid errors.
        faculty_modified = self.faculty_modified or '1901'
        faculty_seen = self.faculty_seen or '1901'
        student_modified = self.student_modified or '1901'
        student_seen = self.student_seen or '1901'
        #print_debug("   faculty_modified = '{}'".format(faculty_modified))
        #print_debug("   faculty_seen = '{}'".format(faculty_seen))
        #print_debug("   student_modified = '{}'".format(student_modified))
        #print_debug("   student_seen = '{}'".format(student_seen))
        if faculty_view:
            if Time(faculty_modified) > Time(student_seen):
                css_class = 'brown'
            if Time(student_modified) > Time(faculty_seen):
                css_class = 'darkgreen'
            if not self.submitted:
                if before_due_date:
                    grade = '…'
                else:
                    grade = 'overdue'
                    css_class = 'red'
            else:
                if not self.grade:
                    grade = 'ungraded'
                    css_class = 'green'
                else:
                    grade = self.grade
        else:
            if Time(student_modified) > Time(faculty_seen):
                css_class = 'brown'
            if Time(faculty_modified) > Time(student_seen):
                css_class = 'darkgreen'
            if not self.submitted:
                if before_due_date:
                    grade = '…'
                else:
                    grade = 'l͟a͟t͟e͟'  # l͟a͟t͟e͟
                    css_class = 'green'
            else:
                if not self.grade:
                    grade = 'ungraded'
                    css_class = 'brown'
                else:
                    grade = self.grade
        if self.grade:             # If a grade has been assigned, show it. Period.
            grade = self.grade
        return (grade, css_class)

def init_db():
    """ Create base database objects """
    # i.e. roles & site course.
    # The Roles data must be in place for the login system to work.
    # And the Umber course must exist for user photos and site docs
    # and admin user role.
    # The sql database must already exist; see bin/init_db .
    # All these are "get_or_create", so running 'em multiple times won't hurt.
    Role.create_defaults()
    Course.create_site()

def populate_production_db(interactive=False):
    """ create initial objects for production database """
    # see umber/bin/init_db
    from utilities import toggle_debug
    toggle_debug()
    make_admin = False
    if interactive:
        make_admin = input(' Create admin? (y/n) ').lower()[0] == 'y'
        if admin:
            admin_username = input(' Admin username? ')
            admin_name = input(' Admin full name? ')
            admin_passwd = input(' Admin password? ')
            admin_email = input(' Admin email? ')
    with db.atomic():
        defaultcourse = Course.create_course(
            name = 'Default Course',
            name_as_title = 'Default<br>Course',
            path = 'default_course',
            start = '2018-01-01',
            copyfrom = False
            )
        if make_admin:
            (admin, created) = Person.get_or_create(username = admin_username)
            if created:
                admin.name = admin_name
                admin.email = admin_email
                password = admin_passwd
            else:
                if interactive:
                    print(f'   username "{admin_username}" already exists')
                    print('      ... setting their is_admin=True')
                    print('      ... leaving their name & email unchanged.')
            admin.is_admin = True
            admin.save()
    toggle_debug()    
    
def populate_db():
    """ Create test & example development objects """
    # i.e. democourse, jane, ted, john, adam; examples and tests.
    #print("Populating development database.")

    from utilities import toggle_debug
    toggle_debug()
    
    with db.atomic():
        student = Role.by_name('student')
        faculty = Role.by_name('faculty')

        democourse = Course.create_course(
            name = 'Demo Course',
            name_as_title = 'Demo<br>Course',
            path = 'demo',
            start = '2018-01-01',
            copyfrom = False
            )

        defaultcourse = Course.create_course(
            name = 'Default Course',
            name_as_title = 'Default<br>Course',
            path = 'default_course',
            start = '2018-01-01',
            copyfrom = False
            )
        
        jane = Person.create_person(
            username = 'janedoe',
            name = 'Jane Q. Doe',
            email = 'janedoe@fake.address',
            password = 'test' )
        
        john = Person.create_person(
            username = 'johnsmith',
            name = 'Johnny Smith',
            email = 'johnsmith@fake.address',
            password = 'test' )
        
        ted = Person.create_person(
            username = 'tedteacher',
            name = 'Ted Teacher',
            email = 'ted@fake.address',
            password = 'test' )

        adam = Person.create_person(
            username = 'adamadmin',
            name = 'Adam Administrator',
            email = 'adam@fake.address',
            password = 'test',
            is_admin = True )
        
        default_date = '2018-01-02'
        democourse.enroll(john, 'student', default_date, create_work=False)
        democourse.enroll(jane, 'student', default_date, create_work=False)
        democourse.enroll(ted,  'faculty', default_date, create_work=False)

        # Assignments are set with a dict {nth: {name, due, blurb}.
        assignments_data = {
            1: {'name': 'week 1',
                'due': '2018-01-23',
                'blurb': 'Do chap 1 exercises 1 to 10.'},
            2: {'name': 'week 2',
                'due': 'Jan 28 2018 5pm',
                'blurb': 'Write a four part fugue.'}
            }
        democourse.update_assignments(assignments_data)
        assign1 = democourse.get_assignment_by_nth(1)

        johns_work = assign1.get_work(john)
        johns_work.grade = 'B'
        johns_work.submitted = '2018-01-22T18:20:23-05:00'      # on time
        johns_work.student_seen = johns_work.submitted
        johns_work.student_modified = johns_work.submitted
        johns_work.faculty_seen = '2018-01-28T16:00:00-05:00'
        johns_work.faculty_modified = johns_work.faculty_seen
        johns_work.save()

        janes_work = assign1.get_work(jane)
        janes_work.submitted = '2018-02-04T22:23:24-05:00',   # past due
        # janes_work.grade = ''                               # not graded yet
        janes_work.student_seen = janes_work.submitted
        janes_work.student_modified = janes_work.submitted
        janes_work.save()

    toggle_debug()
    
if __name__ == '__main__':
    import doctest
    doctest.testmod()
